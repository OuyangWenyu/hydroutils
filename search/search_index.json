{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to hydroutils","text":"<p>A collection of commonly used util functions in hydrological modeling</p> <ul> <li>Free software: MIT license</li> <li>Documentation: https://OuyangWenyu.github.io/hydroutils</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the giswqs/pypackage project template.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/OuyangWenyu/hydroutils/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>hydroutils could always use more documentation, whether as part of the official hydroutils docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/OuyangWenyu/hydroutils/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up hydroutils for local development.</p> <ol> <li> <p>Fork the hydroutils repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/hydroutils.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv hydroutils\n$ cd hydroutils/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 hydroutils tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and     for PyPy. Check https://github.com/OuyangWenyu/hydroutils/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"hydro_plot/","title":"hydro_plot module","text":""},{"location":"hydro_plot/#hydro_plot-module","title":"hydro_plot module","text":"<p>Author: Wenyu Ouyang Date: 2022-12-02 10:59:30 LastEditTime: 2025-01-17 17:30:55 LastEditors: Wenyu Ouyang Description: Some common plots for hydrology FilePath: \\hydroutils\\hydroutils\\hydro_plot.py Copyright (c) 2021-2022 Wenyu Ouyang. All rights reserved.</p>"},{"location":"hydro_plot/#hydroutils.hydro_plot.create_median_labels","title":"<code>create_median_labels(ax, medians_value, percent25value=None, percent75value=None, size='small')</code>","text":"<p>\"create median labels for boxes in a boxplot Parameters</p> <p>ax : plt.AxesSubplot     an ax in a fig medians_value : np.array     description percent25value : type, optional     description, by default None percent75value : type, optional     description, by default None size : str, optional     the size of median-value labels, by default small</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def create_median_labels(\n    ax, medians_value, percent25value=None, percent75value=None, size=\"small\"\n):\n    \"\"\" \"create median labels for boxes in a boxplot\n    Parameters\n    ----------\n    ax : plt.AxesSubplot\n        an ax in a fig\n    medians_value : np.array\n        _description_\n    percent25value : _type_, optional\n        _description_, by default None\n    percent75value : _type_, optional\n        _description_, by default None\n    size : str, optional\n        the size of median-value labels, by default small\n    \"\"\"\n    decimal_places = \"2\"\n    if percent25value is None or percent75value is None:\n        vertical_offset = np.min(medians_value * 0.01)  # offset from median for display\n    else:\n        per25min = np.min(percent25value)\n        per75max = np.max(percent75value)\n        vertical_offset = (per75max - per25min) * 0.01\n    median_labels = [format(s, f\".{decimal_places}f\") for s in medians_value]\n    pos = range(len(medians_value))\n    for xtick in ax.get_xticks():\n        ax.text(\n            pos[xtick],\n            medians_value[xtick] + vertical_offset,\n            median_labels[xtick],\n            horizontalalignment=\"center\",\n            color=\"w\",\n            # https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.text.html\n            size=size,\n            weight=\"semibold\",\n        )\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_boxes_matplotlib","title":"<code>plot_boxes_matplotlib(data, label1=None, label2=None, leg_col=None, colorlst='rbgcmywrbgcmyw', title=None, figsize=(8, 6), sharey=False, xticklabel=None, axin=None, ylim=None, ylabel=None, notch=False, widths=0.5, subplots_adjust_wspace=0.2, show_median=True, median_line_color='black', median_font_size='small')</code>","text":"<p>Plot multiplt boxes for multiple indicators Parameters</p> <p>data : list     one element for one indictor, which could have multiple numpy array and each of them will be showed in a box label1 : list, optional     name of each subplot, by default None label2 : list, optional     legends' names, i.e. name of each box in one subplot (same in all subplots), by default None leg_col: int, optional     number of cols for legend colorlst : str, optional     description, by default \"rbkgcmywrbkgcmyw\" title : type, optional     description, by default None figsize : tuple, optional     description, by default (10, 8) sharey : bool, optional     If true, all subplots share same y axis, by default False xticklabel : type, optional     description, by default None axin : type, optional     description, by default None ylim : type, optional     description, by default None ylabel : type, optional     description, by default None notch: boolean, optional     if True, the median of a box will be a notch, by default False widths : float, optional     description, by default 0.5 subplots_adjust_wspace: float     specifies the size of width for white space between subplots (called padding), as a fraction of the average Axes width. Default size is 0.2 show_median: boolean     if True, we show the median values, by default True median_line_color: str     color of median lines, by default \"black\" median_font_size: str     size of median font Returns</p> <p>type description</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_boxes_matplotlib(\n    data: list,\n    label1: list = None,\n    label2: list = None,\n    leg_col: int = None,\n    colorlst=\"rbgcmywrbgcmyw\",\n    title=None,\n    figsize=(8, 6),\n    sharey=False,\n    xticklabel=None,\n    axin=None,\n    ylim=None,\n    ylabel=None,\n    notch=False,\n    widths=0.5,\n    subplots_adjust_wspace=0.2,\n    show_median=True,\n    median_line_color=\"black\",\n    median_font_size=\"small\",\n):\n    \"\"\"Plot multiplt boxes for multiple indicators\n    Parameters\n    ----------\n    data : list\n        one element for one indictor, which could have multiple numpy array and each of them will be showed in a box\n    label1 : list, optional\n        name of each subplot, by default None\n    label2 : list, optional\n        legends' names, i.e. name of each box in one subplot (same in all subplots), by default None\n    leg_col: int, optional\n        number of cols for legend\n    colorlst : str, optional\n        _description_, by default \"rbkgcmywrbkgcmyw\"\n    title : _type_, optional\n        _description_, by default None\n    figsize : tuple, optional\n        _description_, by default (10, 8)\n    sharey : bool, optional\n        If true, all subplots share same y axis, by default False\n    xticklabel : _type_, optional\n        _description_, by default None\n    axin : _type_, optional\n        _description_, by default None\n    ylim : _type_, optional\n        _description_, by default None\n    ylabel : _type_, optional\n        _description_, by default None\n    notch: boolean, optional\n        if True, the median of a box will be a notch, by default False\n    widths : float, optional\n        _description_, by default 0.5\n    subplots_adjust_wspace: float\n        specifies the size of width for white space between subplots (called padding), as a fraction of the average Axes width. Default size is 0.2\n    show_median: boolean\n        if True, we show the median values, by default True\n    median_line_color: str\n        color of median lines, by default \"black\"\n    median_font_size: str\n        size of median font\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    nc = len(data)\n    if axin is None:\n        fig, axes = plt.subplots(\n            ncols=nc, sharey=sharey, figsize=figsize, constrained_layout=False\n        )\n    else:\n        axes = axin\n\n    # the next few lines are for showing median values\n    decimal_places = \"2\"\n    for k in range(nc):\n        ax = axes[k] if nc &gt; 1 else axes\n        temp = data[k]\n        if type(temp) is list:\n            for kk in range(len(temp)):\n                tt = temp[kk]\n                if tt is not None and len(tt) &gt; 0:\n                    tt = tt[~np.isnan(tt)]\n                    temp[kk] = tt\n                else:\n                    temp[kk] = []\n        else:\n            temp = temp[~np.isnan(temp)]\n        bp = ax.boxplot(\n            temp, patch_artist=True, notch=notch, showfliers=False, widths=widths\n        )\n        for median in bp[\"medians\"]:\n            median.set_color(median_line_color)\n        medians_value = [np.median(tmp) for tmp in temp]\n        percent25value = [np.percentile(tmp, 25) for tmp in temp]\n        percent75value = [np.percentile(tmp, 75) for tmp in temp]\n        per25min = np.min(percent25value)\n        per75max = np.max(percent75value)\n        median_labels = [format(s, f\".{decimal_places}f\") for s in medians_value]\n        pos = range(len(medians_value))\n        if show_median:\n            for tick, label in zip(pos, ax.get_xticklabels()):\n                # params of ax.text could be seen here: https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.text.html\n                ax.text(\n                    pos[tick] + 1,\n                    medians_value[tick] + (per75max - per25min) * 0.01,\n                    median_labels[tick],\n                    horizontalalignment=\"center\",\n                    # https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.text.html\n                    size=median_font_size,\n                    weight=\"semibold\",\n                    color=median_line_color,\n                )\n        for kk in range(len(bp[\"boxes\"])):\n            plt.setp(bp[\"boxes\"][kk], facecolor=colorlst[kk])\n\n        if label1 is not None:\n            ax.set_xlabel(label1[k])\n        else:\n            ax.set_xlabel(str(k))\n        if xticklabel is None:\n            ax.set_xticks([])\n        else:\n            ax.set_xticks([y + 1 for y in range(0, len(data[k]), 2)])\n            ax.set_xticklabels(xticklabel)\n        if ylabel is not None:\n            ax.set_ylabel(ylabel[k])\n        if ylim is not None:\n            ax.set_ylim(ylim[k])\n    if label2 is not None:\n        plt.legend(\n            bp[\"boxes\"],\n            label2,\n            # explanation for bbox_to_anchor: https://zhuanlan.zhihu.com/p/101059179\n            bbox_to_anchor=(1.0, 1.02, 0.25, 0.05),\n            loc=\"upper right\",\n            borderaxespad=0,\n            ncol=len(label2) if leg_col is None else leg_col,\n            frameon=False,\n            fontsize=12,\n        )\n    if title is not None:\n        # fig.suptitle(title)\n        ax.set_title(title)\n    plt.tight_layout()\n    plt.subplots_adjust(wspace=subplots_adjust_wspace)\n    return fig if axin is None else (ax, bp)\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_boxs","title":"<code>plot_boxs(data, x_name, y_name, uniform_color=None, swarm_plot=False, hue=None, colormap=False, xlim=None, ylim=None, order=None, font='serif', rotation=45, show_median=False)</code>","text":"<p>plot multiple boxes in one ax with seaborn Parameters</p> <p>data : pd.DataFrame     a tidy pandas dataframe;     if you don't know what is \"tidy data\", please read: https://github.com/jizhang/pandas-tidy-data x_name : str     the names of each box y_name : str     what is shown uniform_color : str, optional     unified color for all boxes, by default None swarm_plot : bool, optional     description, by default False hue : type, optional     description, by default None colormap : bool, optional     description, by default False xlim : type, optional     description, by default None ylim : type, optional     description, by default None order : type, optional     description, by default None font : str, optional     description, by default \"serif\" rotation : int, optional     rotation for labels in x-axis, by default 45 show_median: bool, optional     if True, show median value for each box, by default False Returns</p> <p>type description</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_boxs(\n    data: pd.DataFrame,\n    x_name: str,\n    y_name: str,\n    uniform_color=None,\n    swarm_plot=False,\n    hue=None,\n    colormap=False,\n    xlim=None,\n    ylim=None,\n    order=None,\n    font=\"serif\",\n    rotation=45,\n    show_median=False,\n):\n    \"\"\"plot multiple boxes in one ax with seaborn\n    Parameters\n    ----------\n    data : pd.DataFrame\n        a tidy pandas dataframe;\n        if you don't know what is \"tidy data\", please read: https://github.com/jizhang/pandas-tidy-data\n    x_name : str\n        the names of each box\n    y_name : str\n        what is shown\n    uniform_color : str, optional\n        unified color for all boxes, by default None\n    swarm_plot : bool, optional\n        _description_, by default False\n    hue : _type_, optional\n        _description_, by default None\n    colormap : bool, optional\n        _description_, by default False\n    xlim : _type_, optional\n        _description_, by default None\n    ylim : _type_, optional\n        _description_, by default None\n    order : _type_, optional\n        _description_, by default None\n    font : str, optional\n        _description_, by default \"serif\"\n    rotation : int, optional\n        rotation for labels in x-axis, by default 45\n    show_median: bool, optional\n        if True, show median value for each box, by default False\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    fig = plt.figure()\n    sns.set(style=\"ticks\", palette=\"pastel\", font=font, font_scale=1.5)\n    # Draw a nested boxplot to show bills by day and time\n    if uniform_color is not None:\n        sns_box = sns.boxplot(\n            x=x_name,\n            y=y_name,\n            data=data,\n            color=uniform_color,\n            showfliers=False,\n            order=order,\n        )\n    else:\n        sns_box = sns.boxplot(\n            x=x_name, y=y_name, data=data, showfliers=False, order=order\n        )\n    if swarm_plot:\n        if hue is None:\n            sns_box = sns.swarmplot(\n                x=x_name, y=y_name, data=data, color=\".2\", order=order\n            )\n        elif colormap:\n            # Create a matplotlib colormap from the sns seagreen color palette\n            cmap = sns.light_palette(\"seagreen\", reverse=False, as_cmap=True)\n            # Normalize to the range of possible values from df[\"c\"]\n            norm = matplotlib.colors.Normalize(\n                vmin=data[hue].min(), vmax=data[hue].max()\n            )\n            colors = {cval: cmap(norm(cval)) for cval in data[hue]}\n            # plot the swarmplot with the colors dictionary as palette, s=2 means size is 2\n            sns_box = sns.swarmplot(\n                x=x_name,\n                y=y_name,\n                hue=hue,\n                s=2,\n                data=data,\n                palette=colors,\n                order=order,\n            )\n            # remove the legend, because we want to set a colorbar instead\n            plt.gca().legend_.remove()\n            # create colorbar\n            divider = make_axes_locatable(plt.gca())\n            ax_cb = divider.new_horizontal(size=\"5%\", pad=0.05)\n            fig = sns_box.get_figure()\n            fig.add_axes(ax_cb)\n            cb1 = matplotlib.colorbar.ColorbarBase(\n                ax_cb, cmap=cmap, norm=norm, orientation=\"vertical\"\n            )\n            cb1.set_label(\"Some Units\")\n        else:\n            palette = sns.light_palette(\"seagreen\", reverse=False, n_colors=10)\n            sns_box = sns.swarmplot(\n                x=x_name,\n                y=y_name,\n                hue=hue,\n                s=2,\n                data=data,\n                palette=palette,\n                order=order,\n            )\n    if xlim is not None:\n        plt.xlim(xlim[0], xlim[1])\n    if ylim is not None:\n        plt.ylim(ylim[0], ylim[1])\n    if show_median:\n        medians = data.groupby([x_name], sort=False)[y_name].median().values\n        create_median_labels(sns_box, medians_value=medians, size=\"x-small\")\n    sns.despine()\n    locs, labels = plt.xticks()\n    plt.setp(labels, rotation=rotation)\n    # plt.show()\n    return sns_box.get_figure()\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_diff_boxes","title":"<code>plot_diff_boxes(data, row_and_col=None, y_col=None, x_col=None, hspace=0.3, wspace=1, title_str=None, title_font_size=14)</code>","text":"<p>plot boxplots in rows and cols</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_diff_boxes(\n    data,\n    row_and_col=None,\n    y_col=None,\n    x_col=None,\n    hspace=0.3,\n    wspace=1,\n    title_str=None,\n    title_font_size=14,\n):\n    \"\"\"plot boxplots in rows and cols\"\"\"\n    # matplotlib.use('TkAgg')\n    if type(data) is not pd.DataFrame:\n        data = pd.DataFrame(data)\n    subplot_num = data.shape[1] if y_col is None else len(y_col)\n    if row_and_col is None:\n        row_num = 1\n        col_num = subplot_num\n        f, axes = plt.subplots(row_num, col_num)\n        plt.subplots_adjust(hspace=hspace, wspace=wspace)\n    else:\n        assert subplot_num &lt;= row_and_col[0] * row_and_col[1]\n        row_num = row_and_col[0]\n        col_num = row_and_col[1]\n        f, axes = plt.subplots(row_num, col_num)\n        f.tight_layout()\n    for i in range(subplot_num):\n        if y_col is None:\n            if row_num == 1 or col_num == 1:\n                sns.boxplot(\n                    y=data.columns.values[i],\n                    data=data,\n                    width=0.5,\n                    orient=\"v\",\n                    ax=axes[i],\n                    showfliers=False,\n                ).set(xlabel=data.columns.values[i], ylabel=\"\")\n            else:\n                row_idx = int(i / col_num)\n                col_idx = i % col_num\n                sns.boxplot(\n                    y=data.columns.values[i],\n                    data=data,\n                    orient=\"v\",\n                    ax=axes[row_idx, col_idx],\n                    showfliers=False,\n                )\n        else:\n            assert x_col is not None\n            if row_num == 1 or col_num == 1:\n                sns.boxplot(\n                    x=data.columns.values[x_col],\n                    y=data.columns.values[y_col[i]],\n                    data=data,\n                    orient=\"v\",\n                    ax=axes[i],\n                    showfliers=False,\n                )\n            else:\n                row_idx = int(i / col_num)\n                col_idx = i % col_num\n                sns.boxplot(\n                    x=data.columns.values[x_col],\n                    y=data.columns.values[y_col[i]],\n                    data=data,\n                    orient=\"v\",\n                    ax=axes[row_idx, col_idx],\n                    showfliers=False,\n                )\n    if title_str is not None:\n        f.suptitle(title_str, fontsize=title_font_size)\n    return f\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_ecdf","title":"<code>plot_ecdf(mydataframe, mycolumn, save_file=None)</code>","text":"<p>Empirical cumulative distribution function</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_ecdf(mydataframe, mycolumn, save_file=None):\n    \"\"\"Empirical cumulative distribution function\"\"\"\n    x, y = ecdf(mydataframe[mycolumn])\n    df = pd.DataFrame({\"x\": x, \"y\": y})\n    sns.set_style(\"ticks\", {\"axes.grid\": True})\n    sns.lineplot(x=\"x\", y=\"y\", data=df, estimator=None).set(\n        xlim=(0, 1), xticks=np.arange(0, 1, 0.05), yticks=np.arange(0, 1, 0.05)\n    )\n    plt.show()\n    if save_file is not None:\n        plt.savefig(save_file)\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_ecdfs","title":"<code>plot_ecdfs(xs, ys, legends=None, style=None, case_str='case', event_str='event', x_str='x', y_str='y', ax_as_subplot=None, interval=0.1)</code>","text":"<p>Empirical cumulative distribution function</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_ecdfs(\n    xs,\n    ys,\n    legends=None,\n    style=None,\n    case_str=\"case\",\n    event_str=\"event\",\n    x_str=\"x\",\n    y_str=\"y\",\n    ax_as_subplot=None,\n    interval=0.1,\n):\n    \"\"\"Empirical cumulative distribution function\"\"\"\n    assert isinstance(xs, list) and isinstance(ys, list)\n    assert len(xs) == len(ys)\n    if legends is not None:\n        assert isinstance(legends, list)\n        assert len(ys) == len(legends)\n    if style is not None:\n        assert isinstance(style, list)\n        assert len(ys) == len(style)\n    for y in ys:\n        assert all(xi &lt; yi for xi, yi in zip(y, y[1:]))\n    frames = []\n    for i in range(len(xs)):\n        str_i = x_str + str(i) if legends is None else legends[i]\n        assert all(xi &lt; yi for xi, yi in zip(xs[i], xs[i][1:]))\n        df_dict_i = {\n            x_str: xs[i],\n            y_str: ys[i],\n            case_str: np.full([xs[i].size], str_i),\n        }\n        if style is not None:\n            df_dict_i[event_str] = np.full([xs[i].size], style[i])\n        df_i = pd.DataFrame(df_dict_i)\n        frames.append(df_i)\n    df = pd.concat(frames)\n    sns.set_style(\"ticks\", {\"axes.grid\": True})\n    if style is None:\n        return (\n            sns.lineplot(x=x_str, y=y_str, hue=case_str, data=df, estimator=None).set(\n                xlim=(0, 1),\n                xticks=np.arange(0, 1, interval),\n                yticks=np.arange(0, 1, interval),\n            )\n            if ax_as_subplot is None\n            else sns.lineplot(\n                ax=ax_as_subplot,\n                x=x_str,\n                y=y_str,\n                hue=case_str,\n                data=df,\n                estimator=None,\n            ).set(\n                xlim=(0, 1),\n                xticks=np.arange(0, 1, interval),\n                yticks=np.arange(0, 1, interval),\n            )\n        )\n    elif ax_as_subplot is None:\n        return sns.lineplot(\n            x=x_str,\n            y=y_str,\n            hue=case_str,\n            style=event_str,\n            data=df,\n            estimator=None,\n        ).set(\n            xlim=(0, 1),\n            xticks=np.arange(0, 1, interval),\n            yticks=np.arange(0, 1, interval),\n        )\n    else:\n        return sns.lineplot(\n            ax=ax_as_subplot,\n            x=x_str,\n            y=y_str,\n            hue=case_str,\n            style=event_str,\n            data=df,\n            estimator=None,\n        ).set(\n            xlim=(0, 1),\n            xticks=np.arange(0, 1, interval),\n            yticks=np.arange(0, 1, interval),\n        )\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_ecdfs_matplot","title":"<code>plot_ecdfs_matplot(xs, ys, legends=None, colors='rbkgcmy', dash_lines=None, x_str='x', y_str='y', x_interval=0.1, y_interval=0.1, x_lim=(0, 1), y_lim=(0, 1), show_legend=True, legend_font_size=16, fig_size=(8, 6))</code>","text":"<p>Empirical cumulative distribution function with matplotlib Parameters</p> <p>xs : type description ys : type description legends : type, optional     description, by default None colors : str, optional     description, by default \"rbkgcmy\" dash_lines : type, optional     description, by default None x_str : str, optional     description, by default \"x\" y_str : str, optional     description, by default \"y\" x_interval : float, optional     description, by default 0.1 y_interval : float, optional     description, by default 0.1 x_lim : tuple, optional     description, by default (0, 1) y_lim : tuple, optional     description, by default (0, 1) show_legend : bool, optional     description, by default True legend_font_size : int, optional     description, by default 16 fig_size : tuple, optional     size of the figure, by default (8, 6) Returns</p> <p>type description</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_ecdfs_matplot(\n    xs,\n    ys,\n    legends=None,\n    colors=\"rbkgcmy\",\n    dash_lines=None,\n    x_str=\"x\",\n    y_str=\"y\",\n    x_interval=0.1,\n    y_interval=0.1,\n    x_lim=(0, 1),\n    y_lim=(0, 1),\n    show_legend=True,\n    legend_font_size=16,\n    fig_size=(8, 6),\n):\n    \"\"\"Empirical cumulative distribution function with matplotlib\n    Parameters\n    ----------\n    xs : _type_\n        _description_\n    ys : _type_\n        _description_\n    legends : _type_, optional\n        _description_, by default None\n    colors : str, optional\n        _description_, by default \"rbkgcmy\"\n    dash_lines : _type_, optional\n        _description_, by default None\n    x_str : str, optional\n        _description_, by default \"x\"\n    y_str : str, optional\n        _description_, by default \"y\"\n    x_interval : float, optional\n        _description_, by default 0.1\n    y_interval : float, optional\n        _description_, by default 0.1\n    x_lim : tuple, optional\n        _description_, by default (0, 1)\n    y_lim : tuple, optional\n        _description_, by default (0, 1)\n    show_legend : bool, optional\n        _description_, by default True\n    legend_font_size : int, optional\n        _description_, by default 16\n    fig_size : tuple, optional\n        size of the figure, by default (8, 6)\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    assert isinstance(xs, list) and isinstance(ys, list)\n    assert len(xs) == len(ys)\n    if legends is not None:\n        assert isinstance(legends, list) and len(ys) == len(legends)\n    if dash_lines is not None:\n        assert isinstance(dash_lines, list)\n    else:\n        dash_lines = np.full(len(xs), False).tolist()\n    for y in ys:\n        assert all(xi &lt; yi for xi, yi in zip(y, y[1:]))\n    fig = plt.figure(figsize=fig_size)\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n    for i in range(len(xs)):\n        if (\n            np.nanmax(np.array(xs[i])) == np.inf\n            or np.nanmin(np.array(xs[i])) == -np.inf\n        ):\n            assert all(xi &lt;= yi for xi, yi in zip(xs[i], xs[i][1:]))\n        else:\n            assert all(xi &lt;= yi for xi, yi in zip(xs[i], xs[i][1:]))\n        (line_i,) = ax.plot(xs[i], ys[i], color=colors[i], label=legends[i])\n        if dash_lines[i]:\n            line_i.set_dashes([2, 2, 10, 2])\n\n    plt.xlabel(x_str, fontsize=18)\n    plt.ylabel(y_str, fontsize=18)\n    ax.set_xlim(x_lim[0], x_lim[1])\n    ax.set_ylim(y_lim[0], y_lim[1])\n    # set x y number font size\n    plt.xticks(np.arange(x_lim[0], x_lim[1] + x_lim[1] / 100, x_interval), fontsize=16)\n    plt.yticks(np.arange(y_lim[0], y_lim[1] + y_lim[1] / 100, y_interval), fontsize=16)\n    if show_legend:\n        ax.legend()\n        plt.legend(prop={\"size\": legend_font_size})\n    plt.grid()\n    # Hide the right and top spines\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    return fig, ax\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_heat_map","title":"<code>plot_heat_map(data, mask=None, fig_size=None, fmt='d', square=True, annot=True, xticklabels=True, yticklabels=True)</code>","text":"<p>Plot a heat map for data https://zhuanlan.zhihu.com/p/96040773?from_voters_page=true Parameters</p> <p>data : pd.DataFrame     2-d array mask: np.array     a boolean array, if True, data in the position will not be shown fig_size: tuple     the size of this figure fmt: str, optional     String formatting code to use when adding annotations. annot: boolean     Annotate each cell with the numeric value using integer formatting</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_heat_map(\n    data,\n    mask=None,\n    fig_size=None,\n    fmt=\"d\",\n    square=True,\n    annot=True,\n    xticklabels=True,\n    yticklabels=True,\n):\n    \"\"\"Plot a heat map for data\n    https://zhuanlan.zhihu.com/p/96040773?from_voters_page=true\n    Parameters\n    ----------\n    data : pd.DataFrame\n        2-d array\n    mask: np.array\n        a boolean array, if True, data in the position will not be shown\n    fig_size: tuple\n        the size of this figure\n    fmt: str, optional\n        String formatting code to use when adding annotations.\n    annot: boolean\n        Annotate each cell with the numeric value using integer formatting\n    \"\"\"\n    if fig_size is not None:\n        fig = plt.figure(figsize=fig_size)\n    ax = sns.heatmap(\n        data=data,\n        square=square,\n        annot=annot,\n        fmt=fmt,\n        cmap=\"RdBu_r\",\n        mask=mask,\n        xticklabels=xticklabels,\n        yticklabels=yticklabels,\n    )\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_map_carto","title":"<code>plot_map_carto(data, lat, lon, fig=None, ax=None, pertile_range=None, value_range=None, fig_size=(8, 8), need_colorbar=True, colorbar_size=[0.91, 0.318, 0.02, 0.354], cmap_str='jet', idx_lst=None, markers=None, marker_size=20, is_discrete=False, colors='rbkgcmywrbkgcmyw', category_names=None, legend_font_size=None, colorbar_font_size=None)</code>","text":"<p>summary</p>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_map_carto--parameters","title":"Parameters","text":"<p>data : np.array     data shown in the map, 1-d array, one value for one point lat : np.array     1-d array, latitude of each point lon : np.array     1-d array, longitude of each point fig : type, optional     description, by default None ax : type, optional     description, by default None pertile_range : list, optional     value's range shown in the map, by default None     for example, [0, 100] means all data; [23, 75] means 25-quantile to 75-quantile values value_range: list, optinal     if value_range is not None, its values are used rather than percential_range fig_size : tuple, optional     description, by default (8, 8) need_colorbar : bool, optional     description, by default True colorbar_size : list, optional     size of colorbar, by default [0.91, 0.318, 0.02, 0.354] cmap_str : str, optional     description, by default \"jet\" idx_lst : type, optional     for scatter plot, it is better to use idx_lst to plot multiple-type points, by default None markers : list, optional     the marker shown in the map, by default None marker_size : int, optional     description, by default 20 is_discrete : bool, optional     if True, legend is used, else colorbar is used, by default False colors : str, optional     colors for different parts, by default \"rbkgcmywrbkgcmyw\" category_names : list, optional     shown in the legend when using discrete values, by default None legend_font_size : type, optional     description, by default None colorbar_font_size : float, optional     font size of colorbar, by default None</p>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_map_carto--returns","title":"Returns","text":"<p>type description</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_map_carto(\n    data,\n    lat,\n    lon,\n    fig=None,\n    ax=None,\n    pertile_range=None,\n    value_range=None,\n    fig_size=(8, 8),\n    need_colorbar=True,\n    colorbar_size=[0.91, 0.318, 0.02, 0.354],\n    cmap_str=\"jet\",\n    idx_lst=None,\n    markers=None,\n    marker_size=20,\n    is_discrete=False,\n    colors=\"rbkgcmywrbkgcmyw\",\n    category_names=None,\n    legend_font_size=None,\n    colorbar_font_size=None,\n):\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    data : np.array\n        data shown in the map, 1-d array, one value for one point\n    lat : np.array\n        1-d array, latitude of each point\n    lon : np.array\n        1-d array, longitude of each point\n    fig : _type_, optional\n        _description_, by default None\n    ax : _type_, optional\n        _description_, by default None\n    pertile_range : list, optional\n        value's range shown in the map, by default None\n        for example, [0, 100] means all data; [23, 75] means 25-quantile to 75-quantile values\n    value_range: list, optinal\n        if value_range is not None, its values are used rather than percential_range\n    fig_size : tuple, optional\n        _description_, by default (8, 8)\n    need_colorbar : bool, optional\n        _description_, by default True\n    colorbar_size : list, optional\n        size of colorbar, by default [0.91, 0.318, 0.02, 0.354]\n    cmap_str : str, optional\n        _description_, by default \"jet\"\n    idx_lst : _type_, optional\n        for scatter plot, it is better to use idx_lst to plot multiple-type points, by default None\n    markers : list, optional\n        the marker shown in the map, by default None\n    marker_size : int, optional\n        _description_, by default 20\n    is_discrete : bool, optional\n        if True, legend is used, else colorbar is used, by default False\n    colors : str, optional\n        colors for different parts, by default \"rbkgcmywrbkgcmyw\"\n    category_names : list, optional\n        shown in the legend when using discrete values, by default None\n    legend_font_size : _type_, optional\n        _description_, by default None\n    colorbar_font_size : float, optional\n        font size of colorbar, by default None\n\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    if value_range is not None:\n        vmin = value_range[0]\n        vmax = value_range[1]\n    elif pertile_range is None:\n        # https://blog.csdn.net/chenirene510/article/details/111318539\n        mask_data = np.ma.masked_invalid(data)\n        vmin = np.min(mask_data)\n        vmax = np.max(mask_data)\n    else:\n        assert 0 &lt;= pertile_range[0] &lt; pertile_range[1] &lt;= 100\n        vmin = np.nanpercentile(data, pertile_range[0])\n        vmax = np.nanpercentile(data, pertile_range[1])\n    llcrnrlat = (np.min(lat),)\n    urcrnrlat = (np.max(lat),)\n    llcrnrlon = (np.min(lon),)\n    urcrnrlon = (np.max(lon),)\n    extent = [llcrnrlon[0], urcrnrlon[0], llcrnrlat[0], urcrnrlat[0]]\n    # Figure\n    if fig is None or ax is None:\n        fig, ax = plt.subplots(\n            1, 1, figsize=fig_size, subplot_kw={\"projection\": ccrs.PlateCarree()}\n        )\n    ax.set_extent(extent)\n    states = NaturalEarthFeature(\n        category=\"cultural\",\n        scale=\"50m\",\n        facecolor=\"none\",\n        name=\"admin_1_states_provinces_shp\",\n    )\n    ax.add_feature(states, linewidth=0.5, edgecolor=\"black\")\n    ax.coastlines(\"50m\", linewidth=0.8)\n    if idx_lst is not None:\n        if isinstance(marker_size, list):\n            assert len(marker_size) == len(idx_lst)\n        else:\n            marker_size = np.full(len(idx_lst), marker_size).tolist()\n        if not isinstance(marker_size, list):\n            markers = np.full(len(idx_lst), markers).tolist()\n        else:\n            assert len(markers) == len(idx_lst)\n        if not isinstance(cmap_str, list):\n            cmap_str = np.full(len(idx_lst), cmap_str).tolist()\n        else:\n            assert len(cmap_str) == len(idx_lst)\n        if is_discrete:\n            for i in range(len(idx_lst)):\n                ax.plot(\n                    lon[idx_lst[i]],\n                    lat[idx_lst[i]],\n                    marker=markers[i],\n                    ms=marker_size[i],\n                    label=category_names[i],\n                    c=colors[i],\n                    linestyle=\"\",\n                )\n                ax.legend(prop=dict(size=legend_font_size))\n        else:\n            scatter = []\n            for i in range(len(idx_lst)):\n                scat = ax.scatter(\n                    lon[idx_lst[i]],\n                    lat[idx_lst[i]],\n                    c=data[idx_lst[i]],\n                    marker=markers[i],\n                    s=marker_size[i],\n                    cmap=cmap_str[i],\n                    vmin=vmin,\n                    vmax=vmax,\n                )\n                scatter.append(scat)\n            if need_colorbar:\n                if colorbar_size is not None:\n                    cbar_ax = fig.add_axes(colorbar_size)\n                    cbar = fig.colorbar(scat, cax=cbar_ax, orientation=\"vertical\")\n                else:\n                    cbar = fig.colorbar(scat, ax=ax, pad=0.01)\n                if colorbar_font_size is not None:\n                    cbar.ax.tick_params(labelsize=colorbar_font_size)\n            if category_names is not None:\n                ax.legend(\n                    scatter, category_names, prop=dict(size=legend_font_size), ncol=2\n                )\n    elif is_discrete:\n        scatter = ax.scatter(lon, lat, c=data, s=marker_size)\n        # produce a legend with the unique colors from the scatter\n        legend1 = ax.legend(\n            *scatter.legend_elements(), loc=\"lower left\", title=\"Classes\"\n        )\n        ax.add_artist(legend1)\n    else:\n        scat = plt.scatter(\n            lon, lat, c=data, s=marker_size, cmap=cmap_str, vmin=vmin, vmax=vmax\n        )\n        if need_colorbar:\n            if colorbar_size is not None:\n                cbar_ax = fig.add_axes(colorbar_size)\n                cbar = fig.colorbar(scat, cax=cbar_ax, orientation=\"vertical\")\n            else:\n                cbar = fig.colorbar(scat, ax=ax, pad=0.01)\n            if colorbar_font_size is not None:\n                cbar.ax.tick_params(labelsize=colorbar_font_size)\n    return ax\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_rainfall_runoff","title":"<code>plot_rainfall_runoff(t, p, qs, fig_size=(8, 6), c_lst='rbkgcmy', leg_lst=None, dash_lines=None, title=None, xlabel=None, ylabel=None, prcp_ylabel='prcp(mm/day)', linewidth=1, prcp_interval=20)</code>","text":"<p>Plot rainfall and runoff in one figure</p>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_rainfall_runoff--parameters","title":"Parameters","text":"<p>t : a np.array or a list of some np.array and the length of the list is same as the length of qs     time series, better to be a list with the same length of qs p : np.array     precipitation, a time series qs : a np.array or a list of some np.array     streamflow, a list with multiple time series fig_size : tuple, optional     figure size, by default (8, 6) c_lst : str, optional     colors, by default \"rbkgcmy\" leg_lst : list, optional     legends, by default None dash_lines : list, optional     if a line is dash line, by default None title : str, optional     the title of the figure, by default None xlabel : str, optional     label of x axis, by default None ylabel : str, optional     label of y axis, by default None linewidth : int, optional     the width of lines, by default 1 prcp_interval : int, optional     the interval of precipitation, by default 20</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_rainfall_runoff(\n    t,\n    p,\n    qs,\n    fig_size=(8, 6),\n    c_lst=\"rbkgcmy\",\n    leg_lst=None,\n    dash_lines=None,\n    title=None,\n    xlabel=None,\n    ylabel=None,\n    prcp_ylabel=\"prcp(mm/day)\",\n    linewidth=1,\n    prcp_interval=20,\n):\n    \"\"\"Plot rainfall and runoff in one figure\n\n    Parameters\n    ----------\n    t : a np.array or a list of some np.array and the length of the list is same as the length of qs\n        time series, better to be a list with the same length of qs\n    p : np.array\n        precipitation, a time series\n    qs : a np.array or a list of some np.array\n        streamflow, a list with multiple time series\n    fig_size : tuple, optional\n        figure size, by default (8, 6)\n    c_lst : str, optional\n        colors, by default \"rbkgcmy\"\n    leg_lst : list, optional\n        legends, by default None\n    dash_lines : list, optional\n        if a line is dash line, by default None\n    title : str, optional\n        the title of the figure, by default None\n    xlabel : str, optional\n        label of x axis, by default None\n    ylabel : str, optional\n        label of y axis, by default None\n    linewidth : int, optional\n        the width of lines, by default 1\n    prcp_interval : int, optional\n        the interval of precipitation, by default 20\n    \"\"\"\n    fig, ax = plt.subplots(figsize=fig_size)\n    if dash_lines is not None:\n        assert isinstance(dash_lines, list)\n    else:\n        dash_lines = np.full(len(qs), False).tolist()\n    for k in range(len(qs)):\n        tt = t[k] if type(t) is list else t\n        q = qs[k]\n        leg_str = None\n        if leg_lst is not None:\n            leg_str = leg_lst[k]\n        (line_i,) = ax.plot(tt, q, color=c_lst[k], label=leg_str, linewidth=linewidth)\n        if dash_lines[k]:\n            line_i.set_dashes([2, 2, 10, 2])\n\n    ax.set_ylim(ax.get_ylim()[0], ax.get_ylim()[1] * 1.2)\n    # Create second axes, in order to get the bars from the top you can multiply by -1\n    ax2 = ax.twinx()\n    # ax2.bar(tt, -p, color=\"b\")\n    ax2.fill_between(tt, 0, -p, step=\"mid\", color=\"b\", alpha=0.5)\n    # ax2.plot(tt, -p, color=\"b\", alpha=0.7, linewidth=1.5)\n\n    # Now need to fix the axis labels\n    # max_pre = max(p)\n    max_pre = p.max().item()\n    ax2.set_ylim(-max_pre * 5, 0)\n    y2_ticks = np.arange(0, max_pre, prcp_interval)\n    y2_ticklabels = [str(i) for i in y2_ticks]\n    ax2.set_yticks(-1 * y2_ticks)\n    ax2.set_yticklabels(y2_ticklabels, fontsize=16)\n    # ax2.set_yticklabels([lab.get_text()[1:] for lab in ax2.get_yticklabels()])\n    if title is not None:\n        ax.set_title(title, loc=\"center\", fontdict={\"fontsize\": 17})\n    if ylabel is not None:\n        ax.set_ylabel(ylabel, fontsize=18)\n    if xlabel is not None:\n        ax.set_xlabel(xlabel, fontsize=18)\n    ax2.set_ylabel(prcp_ylabel, fontsize=8, loc=\"top\")\n    # ax2.set_ylabel(\"precipitation (mm/day)\", fontsize=12, loc='top')\n    # https://github.com/matplotlib/matplotlib/issues/12318\n    ax.tick_params(axis=\"x\", labelsize=16)\n    ax.tick_params(axis=\"y\", labelsize=16)\n    ax.legend(bbox_to_anchor=(0.01, 0.85), loc=\"upper left\", fontsize=16)\n    ax.grid()\n    return fig, ax\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_scatter_with_11line","title":"<code>plot_scatter_with_11line(x, y, point_color='blue', line_color='black', xlim=[0.0, 1.0], ylim=[0.0, 1.0], xlabel=None, ylabel=None)</code>","text":"<p>plot a scatter plot for two varaibles with a 1:1 line Parameters</p> <p>x : np.array     the first variable to be plotted y : np.array     the second variable to be plotted point_color: str     the color of scatter points, by default \"blue\" line_color: str     the color of 1:1 line, by default \"black\" xlim: list     points' x_range shown in the plot ylim: list     points' y_range shown in the plot Returns</p> <p>tuple[fig, ax]     the figure and the ax</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_scatter_with_11line(\n    x: np.array,\n    y: np.array,\n    point_color=\"blue\",\n    line_color=\"black\",\n    xlim=[0.0, 1.0],\n    ylim=[0.0, 1.0],\n    xlabel=None,\n    ylabel=None,\n):\n    \"\"\"plot a scatter plot for two varaibles with a 1:1 line\n    Parameters\n    ----------\n    x : np.array\n        the first variable to be plotted\n    y : np.array\n        the second variable to be plotted\n    point_color: str\n        the color of scatter points, by default \"blue\"\n    line_color: str\n        the color of 1:1 line, by default \"black\"\n    xlim: list\n        points' x_range shown in the plot\n    ylim: list\n        points' y_range shown in the plot\n    Returns\n    -------\n    tuple[fig, ax]\n        the figure and the ax\n    \"\"\"\n    fig, ax = plt.subplots()\n    # set background color for ax\n    ax.set_facecolor(\"whitesmoke\")\n    # plot the grid of the figure\n    # plt.grid(color=\"whitesmoke\")\n    ax.scatter(x, y, c=point_color, s=10)\n    line = mlines.Line2D([0, 1], [0, 1], color=line_color, linestyle=\"--\")\n    transform = ax.transAxes\n    line.set_transform(transform)\n    ax.add_line(line)\n    ax.set_xlim(xlim)\n    ax.set_ylim(ylim)\n    plt.xticks(np.arange(xlim[0], xlim[1], 0.1), fontsize=16)\n    plt.yticks(np.arange(ylim[0], ylim[1], 0.1), fontsize=16)\n    # set xlable and ylabel\n    if xlabel is not None:\n        plt.xlabel(xlabel, fontsize=16)\n    if ylabel is not None:\n        plt.ylabel(ylabel, fontsize=16)\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"left\"].set_visible(False)\n    ax.spines[\"bottom\"].set_visible(False)\n    return fig, ax\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_scatter_xyc","title":"<code>plot_scatter_xyc(x_label, x, y_label, y, c_label=None, c=None, size=20, is_reg=False, xlim=None, ylim=None, quadrant=None)</code>","text":"<p>scatter plot: x-y relationship with c as colorbar Parameters</p> <p>x_label : type description x : type description y_label : type description y : type description c_label : type, optional     description, by default None c : type, optional     description, by default None size : int, optional     size of points, by default 20 is_reg : bool, optional     description, by default False xlim : type, optional     description, by default None ylim : type, optional     description, by default None quadrant: list, optional     if it is not None, it should be a list like [0.0,0.0],     the first means we put a new axis in x=0.0, second for y=0.0,     so that we can build a 4-quadrant plot</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_scatter_xyc(\n    x_label,\n    x,\n    y_label,\n    y,\n    c_label=None,\n    c=None,\n    size=20,\n    is_reg=False,\n    xlim=None,\n    ylim=None,\n    quadrant=None,\n):\n    \"\"\"\n    scatter plot: x-y relationship with c as colorbar\n    Parameters\n    ----------\n    x_label : _type_\n        _description_\n    x : _type_\n        _description_\n    y_label : _type_\n        _description_\n    y : _type_\n        _description_\n    c_label : _type_, optional\n        _description_, by default None\n    c : _type_, optional\n        _description_, by default None\n    size : int, optional\n        size of points, by default 20\n    is_reg : bool, optional\n        _description_, by default False\n    xlim : _type_, optional\n        _description_, by default None\n    ylim : _type_, optional\n        _description_, by default None\n    quadrant: list, optional\n        if it is not None, it should be a list like [0.0,0.0],\n        the first means we put a new axis in x=0.0, second for y=0.0,\n        so that we can build a 4-quadrant plot\n    \"\"\"\n    fig, ax = plt.subplots()\n    if type(x) is list:\n        for i in range(len(x)):\n            ax.plot(\n                x[i], y[i], marker=\"o\", linestyle=\"\", ms=size, label=c_label[i], c=c[i]\n            )\n        ax.legend()\n\n    elif c is None:\n        df = pd.DataFrame({x_label: x, y_label: y})\n        points = plt.scatter(df[x_label], df[y_label], s=size)\n        if quadrant is not None:\n            plt.axvline(quadrant[0], c=\"grey\", lw=1, linestyle=\"--\")\n            plt.axhline(quadrant[1], c=\"grey\", lw=1, linestyle=\"--\")\n            q2 = df[(df[x_label] &lt; 0) &amp; (df[y_label] &gt; 0)].shape[0]\n            q3 = df[(df[x_label] &lt; 0) &amp; (df[y_label] &lt; 0)].shape[0]\n            q4 = df[(df[x_label] &gt; 0) &amp; (df[y_label] &lt; 0)].shape[0]\n            q5 = df[(df[x_label] == 0) &amp; (df[y_label] == 0)].shape[0]\n            q1 = df[(df[x_label] &gt; 0) &amp; (df[y_label] &gt; 0)].shape[0]\n            q = q1 + q2 + q3 + q4 + q5\n            r1 = int(round(q1 / q, 2) * 100)\n            r2 = int(round(q2 / q, 2) * 100)\n            r3 = int(round(q3 / q, 2) * 100)\n            r4 = int(round(q4 / q, 2) * 100)\n            r5 = 100 - r1 - r2 - r3 - r4\n            plt.text(\n                xlim[1] - (xlim[1] - xlim[0]) * 0.1,\n                ylim[1] - (ylim[1] - ylim[0]) * 0.1,\n                f\"{r1}%\",\n                fontsize=16,\n            )\n            plt.text(\n                xlim[0] + (xlim[1] - xlim[0]) * 0.1,\n                ylim[1] - (ylim[1] - ylim[0]) * 0.1,\n                f\"{r2}%\",\n                fontsize=16,\n            )\n            plt.text(\n                xlim[0] + (xlim[1] - xlim[0]) * 0.1,\n                ylim[0] + (ylim[1] - ylim[0]) * 0.1,\n                f\"{r3}%\",\n                fontsize=16,\n            )\n            plt.text(\n                xlim[1] - (xlim[1] - xlim[0]) * 0.1,\n                ylim[0] + (ylim[1] - ylim[0]) * 0.1,\n                f\"{r4}%\",\n                fontsize=16,\n            )\n            plt.text(0.2, 0.02, f\"{str(r5)}%\", fontsize=16)\n    else:\n        df = pd.DataFrame({x_label: x, y_label: y, c_label: c})\n        points = plt.scatter(\n            df[x_label], df[y_label], c=df[c_label], s=size, cmap=\"Spectral\"\n        )  # set style options\n        # add a color bar\n        plt.colorbar(points)\n\n    # set limits\n    if xlim is not None:\n        plt.xlim(xlim[0], xlim[1])\n    if ylim is not None:\n        plt.ylim(ylim[0], ylim[1])\n    # Hide the right and top spines\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    # build the regression plot\n    if is_reg:\n        plot = sns.regplot(x_label, y_label, data=df, scatter=False)  # , color=\".1\"\n        plot = plot.set(xlabel=x_label, ylabel=y_label)  # add labels\n    else:\n        plt.xlabel(x_label, fontsize=18)\n        plt.ylabel(y_label, fontsize=18)\n        plt.xticks(fontsize=16)\n        plt.yticks(fontsize=16)\n</code></pre>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_ts","title":"<code>plot_ts(t, y, ax=None, t_bar=None, title=None, xlabel=None, ylabel=None, fig_size=(12, 4), c_lst='rbkgcmyrbkgcmyrbkgcmy', leg_lst=None, marker_lst=None, linewidth=2, linespec=None, dash_lines=None, alpha=1)</code>","text":"<p>Plot time series for multi arrays with matplotlib</p>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_ts--parameters","title":"Parameters","text":"<p>t : Union[list, np.array]     time series but not just date; it can also be numbers like 1, 2, 3, ... y : Union[list, np.array]     shown data series; the len of y should be equal to t's ax : type, optional     description, by default None t_bar : type, optional     description, by default None title : type, optional     description, by default None xlabel: str, optional     the name of x axis, by default None ylabel : str, optional     the name of y axis, by default None fig_size : tuple, optional     description, by default (12, 4) c_lst : str, optional     description, by default \"rbkgcmy\" leg_lst : type, optional     description, by default None marker_lst : type, optional     description, by default None linewidth : int, optional     description, by default 2 linespec : type, optional     description, by default None dash_lines : type, optional     if dash_line, then we will plot dashed line, by default None</p>"},{"location":"hydro_plot/#hydroutils.hydro_plot.plot_ts--returns","title":"Returns","text":"<p>type description</p> Source code in <code>hydroutils/hydro_plot.py</code> <pre><code>def plot_ts(\n    t: Union[list, np.array],\n    y: Union[list, np.array],\n    ax=None,\n    t_bar=None,\n    title=None,\n    xlabel: str = None,\n    ylabel: str = None,\n    fig_size=(12, 4),\n    c_lst=\"rbkgcmyrbkgcmyrbkgcmy\",\n    leg_lst=None,\n    marker_lst=None,\n    linewidth=2,\n    linespec=None,\n    dash_lines=None,\n    alpha=1,\n):\n    \"\"\"Plot time series for multi arrays with matplotlib\n\n    Parameters\n    ----------\n    t : Union[list, np.array]\n        time series but not just date; it can also be numbers like 1, 2, 3, ...\n    y : Union[list, np.array]\n        shown data series; the len of y should be equal to t's\n    ax : _type_, optional\n        _description_, by default None\n    t_bar : _type_, optional\n        _description_, by default None\n    title : _type_, optional\n        _description_, by default None\n    xlabel: str, optional\n        the name of x axis, by default None\n    ylabel : str, optional\n        the name of y axis, by default None\n    fig_size : tuple, optional\n        _description_, by default (12, 4)\n    c_lst : str, optional\n        _description_, by default \"rbkgcmy\"\n    leg_lst : _type_, optional\n        _description_, by default None\n    marker_lst : _type_, optional\n        _description_, by default None\n    linewidth : int, optional\n        _description_, by default 2\n    linespec : _type_, optional\n        _description_, by default None\n    dash_lines : _type_, optional\n        if dash_line, then we will plot dashed line, by default None\n\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    is_new_fig = False\n    if ax is None:\n        fig = plt.figure(figsize=fig_size)\n        ax = fig.subplots()\n        is_new_fig = True\n    if dash_lines is not None:\n        assert isinstance(dash_lines, list)\n    else:\n        dash_lines = np.full(len(t), False).tolist()\n        # dash_lines[-1] = True\n    if type(y) is np.ndarray:\n        y = [y]\n    if type(linewidth) is not list:\n        linewidth = [linewidth] * len(y)\n    if type(alpha) is not list:\n        alpha = [alpha] * len(y)\n    for k in range(len(y)):\n        tt = t[k] if type(t) is list else t\n        yy = y[k]\n        leg_str = None\n        if leg_lst is not None:\n            leg_str = leg_lst[k]\n        if marker_lst is None:\n            (line_i,) = (\n                ax.plot(tt, yy, \"*\", color=c_lst[k], label=leg_str, alpha=alpha[k])\n                if True in np.isnan(yy)\n                else ax.plot(\n                    tt,\n                    yy,\n                    color=c_lst[k],\n                    label=leg_str,\n                    linewidth=linewidth[k],\n                    alpha=alpha[k],\n                )\n            )\n        elif marker_lst[k] == \"-\":\n            if linespec is not None:\n                (line_i,) = ax.plot(\n                    tt,\n                    yy,\n                    color=c_lst[k],\n                    label=leg_str,\n                    linestyle=linespec[k],\n                    lw=linewidth[k],\n                    alpha=alpha[k],\n                )\n            else:\n                (line_i,) = ax.plot(\n                    tt,\n                    yy,\n                    color=c_lst[k],\n                    label=leg_str,\n                    lw=linewidth[k],\n                    alpha=alpha[k],\n                )\n        else:\n            (line_i,) = ax.plot(\n                tt,\n                yy,\n                color=c_lst[k],\n                label=leg_str,\n                marker=marker_lst[k],\n                lw=linewidth[k],\n                alpha=alpha[k],\n            )\n        if dash_lines[k]:\n            line_i.set_dashes([2, 2, 10, 2])\n        if ylabel is not None:\n            ax.set_ylabel(ylabel, fontsize=18)\n        if xlabel is not None:\n            ax.set_xlabel(xlabel, fontsize=18)\n    if t_bar is not None:\n        ylim = ax.get_ylim()\n        t_bar = [t_bar] if type(t_bar) is not list else t_bar\n        for tt in t_bar:\n            ax.plot([tt, tt], ylim, \"-k\")\n\n    if leg_lst is not None:\n        ax.legend(loc=\"upper right\", frameon=False)\n        plt.legend(prop={\"size\": 16})\n    if title is not None:\n        ax.set_title(title, loc=\"center\", fontdict={\"fontsize\": 17})\n    # plot the grid of the figure\n    plt.grid()\n    plt.xticks(fontsize=16)\n    plt.yticks(fontsize=16)\n    # Hide the right and top spines\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    plt.tight_layout()\n    return (fig, ax) if is_new_fig else ax\n</code></pre>"},{"location":"hydroutils/","title":"hydroutils module","text":"<p>Author: Wenyu Ouyang Date: 2022-12-02 10:42:19 LastEditTime: 2023-10-27 14:53:16 LastEditors: Wenyu Ouyang Description: Top-level package for hydroutils. FilePath: /hydroutils/hydroutils/init.py Copyright (c) 2023-2024 Wenyu Ouyang. All rights reserved.</p>"},{"location":"hydroutils/#hydroutils.hydro_logger","title":"<code>hydro_logger(cls)</code>","text":"<p>Class decorator: Adds a logger attribute to the class.</p> Source code in <code>hydroutils/hydro_log.py</code> <pre><code>def hydro_logger(cls):\n    \"\"\"\n    Class decorator: Adds a logger attribute to the class.\n    \"\"\"\n    # Use the class name as the logger name\n    logger_name = f\"{cls.__module__}.{cls.__name__}\"\n    logger = logging.getLogger(logger_name)\n    logger.setLevel(logging.DEBUG)\n    cache_dir = get_cache_dir()\n    log_dir = os.path.join(cache_dir, \"logs\")\n    if not os.path.exists(log_dir):\n        os.makedirs(log_dir)\n    current_time = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    log_file = os.path.join(log_dir, f\"{logger_name}_{current_time}.log\")\n    # Check if handlers have already been added to avoid duplication\n    if not logger.handlers:\n        # Create a file handler to write logs to the specified file\n        file_handler = logging.FileHandler(log_file)\n        file_handler.setLevel(logging.DEBUG)\n\n        # Create a console handler to output logs to the console (optional)\n        console_handler = logging.StreamHandler()\n        console_handler.setLevel(logging.INFO)\n\n        # set the format of the log\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n        file_handler.setFormatter(formatter)\n        console_handler.setFormatter(formatter)\n\n        # Add handlers to the logger\n        logger.addHandler(file_handler)\n        logger.addHandler(console_handler)\n\n    # Bind the logger to the class attribute\n    cls.logger = logger\n    return cls\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install hydroutils, run this command in your terminal:</p> <pre><code>pip install hydroutils\n</code></pre> <p>This is the preferred method to install hydroutils, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>The sources for hydroutils can be downloaded from the Github repo.</p> <p>You can clone the public repository:</p> <pre><code>git clone git://github.com/OuyangWenyu/hydroutils\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use hydroutils in a project:</p> <pre><code>import hydroutils\n</code></pre>"}]}